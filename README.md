# Dots-and-Boxes

Project theme: Artificial intelligence project, machine learning and recursive search methods in Python.

System Expertise: The Dots and Boxes game supports two modes. The first - two human players The second - a player in front of a computer. This game is for anyone who wants to play it.
Rules of the game: The game is built for two players, who in turn add a vertical or horizontal line that connects two adjacent points. The player who completes the fourth side of a 1 × 1 box earns a point and plays another turn. When a player completes a box, his color will be written on it. The goal of each player is to accumulate as many boxes as possible. Victory is seen when the whole board is full. The winner has the largest number of boxes in his suit. When this happens, on the right side of the board will write who the winner is, and there will be an option of a new game.

background:
The project makes extensive use of data structures, mainly lists and two-dimensional matrices. In two-dimensional matrices, I also stored the board itself, all the squares and what they contain inside, as well as the graphics that draw the board. Also within the list I stored a variety of data, as needed for actions. In this project I also used a little dictionary.

Algorithmics (machine learning, artificial intelligence): In the program I wrote I used a number of different algorithms and transitions between them in order to enable the computer to beat the human player in at least 80% of the games.

The algorithms I realized I used are Minmax and Alpha Beta.

The Minmax algorithm produces a tree at a predetermined depth, so that each level in the tree represents all possible moves for the game player (computer or human player) and from each of them, all possible responses to that of the opposing player. , The reactions to player B's game for each action of player A, the reactions of A to B's reactions and so on.
To get the list of possible boards, I use two actions. First, sort_boxes sorts all squares into four lists according to the number of walls painted in it (without squares that have 4 painted walls), and returns the chain of all the lists. In addition it also checks if there is no square where 3 walls are painted and there is another square with 0 painted walls and if this situation exists it selects the square with the 0 and returns it and shortens the operation. The second, next_boards, is the action that actually searches for all possible boards for the minimax. The operation is recursive in a situation where the computer fills a square and has another queue, then you have to find the next best move, otherwise it goes through the list of squares from the operation sort_boxes and updates each of them and their neighbors and puts the board with the update in a new array. When it finishes going through the entire array it returns the list of boards.
The leaves in the resulting tree are static states that we will reach after a sequence of moves (the paths in the tree are actually possible scenarios). A leaf is formed when the recursion reaches the maximum depth or when there is a victory or when the board is full. Any such static state is given a score so that a high score is given to a board that is better for the computer and vice versa. With the help of the score, the computer knows how to choose the best move for it, which will reflect how good the situation is in terms of proximity to victory for the computer. To this end there is the auxiliary action nikud, which is applied only to the spreading tree leaves.
The score for the tree leaves returns to the parent node that created it and then then, assuming the human player also wants to win, the computer actually tries to "predict" the human player's move and therefore, at the tree levels of the human player's possible moves, the computer chooses the course with the lowest score , Who is the best for the human player and at the wooden levels of the possible moves to the computer, is a guy in the course with the highest score, who is the best for the computer.
During the creation of the minmax tree I used a tree pruning method called alpha-beta. The purpose of the method is to reduce the number of sub-trees to walk on when evaluating a possible move in a minimax tree. The algorithm each time keeps the highest score found and the lowest score found, and checks accordingly if there is any point in getting into each new son and testing him. For example: if in one of its sub-trees the 'sex' player managed to get a lower score by one of his own sub-trees than the value returned by the 'max' player (ie the values ​​in beta and alpha are such that the beta is smaller than alpha), the sex player 'There is no need to examine the rest of his sub-trees because he will not choose a higher score than he has now achieved and therefore the' Max 'player (who is his ancestor) will not choose the score that comes from him because he already has a higher score.
Once the action is called Minmax, it leads a chain of calls to auxiliary actions that will eventually lead to choosing the best move for the computer. The action Minmax summons the action play_min which summons play_max which summons play_min and so on. As a result of the operations, it is possible to decrease the levels of the tree and follow the worst move for the player and the best for the computer. The search becomes more efficient with the help of the alpha-beta method I described above.

Implementation: The project is implemented in the Python language and consists of several engines:
Artificial intelligence engine: implementation of the MiniMax algorithm and implementation of the Alpha Beta pruning method. Realization of a number of game modes such as player vs. computer and player vs. player vs. computer at different difficulty levels defined by the depth at which an understanding algorithm seeks out the possible solutions.
Graphic Engine: Using the Tkinter library to create a board on which the graphic game runs. The graphics board consists of canvas, label, buttons, and several other widgets that display the various parts of the game on the screen, in an advanced, interactive and user-friendly way.
Model Engine: The model engine is responsible for running the game properly and continuously, with no bugs and no exceptions during the run. The motor is responsible for the output and input in the system, for checking their integrity. Through this engine the game settings are selected and displayed graphically on the game. The model engine is responsible for transmitting the appropriate and correct data between the various departments in the code:
